name: Deploy to EC2 via ECR

on:
  push:
    branches: [main, develop]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [main]
  workflow_dispatch:  # Allow manual triggering

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}

permissions:
  id-token: write
  contents: read

jobs:
  lint-and-test:
    name: Lint and Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 pytest
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Lint with flake8
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Test with pytest
        run: |
          pytest tests/ -v || echo "No tests found"

  build-and-push:
    name: Build and Push to ECR
    needs: lint-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-,format=short
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image push
        run: |
          aws ecr describe-images \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_REGION }} \
            --image-ids imageTag=latest

  deploy-to-ec2:
    name: Deploy to EC2
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment:
      name: production
      url: http://${{ secrets.EC2_HOST }}
    steps:
      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          timeout: 300s
          command_timeout: 300s
          script: |
            set -euo pipefail
            
            # Configuration
            export AWS_REGION="${{ env.AWS_REGION }}"
            export ECR_REGISTRY="${{ env.ECR_REGISTRY }}"
            export ECR_REPOSITORY="${{ env.ECR_REPOSITORY }}"
            export IMAGE_TAG="latest"
            export CONTAINER_NAME="my-app-container"
            export HOST_PORT="80"
            export CONTAINER_PORT="4000"
            
            # Colors for output
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            RED='\033[0;31m'
            NC='\033[0m'
            
            log() {
                echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
            }
            
            warn() {
                echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING:${NC} $1"
            }
            
            error() {
                echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1"
            }
            
            log "üöÄ Starting deployment..."
            
            # Check available disk space
            AVAILABLE_SPACE=$(df / | tail -1 | awk '{print $4}')
            if [ "$AVAILABLE_SPACE" -lt 2000000 ]; then
                warn "Low disk space detected. Cleaning up Docker resources..."
                docker system prune -f --volumes
            fi
            
            # Login to ECR
            log "üîê Logging into ECR..."
            aws ecr get-login-password --region $AWS_REGION | \
                docker login --username AWS --password-stdin $ECR_REGISTRY
            
            # Pull latest image
            log "üì• Pulling latest image..."
            docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
            
            # Create backup of current container
            if docker ps -q -f name=$CONTAINER_NAME | grep -q .; then
                log "üíæ Creating backup..."
                docker commit $CONTAINER_NAME ${CONTAINER_NAME}-backup-$(date +%Y%m%d-%H%M%S) || true
            fi
            
            # Stop existing container
            log "üõë Stopping existing container..."
            docker stop $CONTAINER_NAME 2>/dev/null || log "No existing container to stop"
            docker rm $CONTAINER_NAME 2>/dev/null || log "No existing container to remove"
            
            # Run new container
            log "üé¨ Starting new container..."
            docker run -d \
                --name $CONTAINER_NAME \
                --restart unless-stopped \
                -p $HOST_PORT:$CONTAINER_PORT \
                -e ENVIRONMENT="production" \
                -e AWS_DEFAULT_REGION=$AWS_REGION \
                -e DEPLOYED_BY="github-actions" \
                -e DEPLOYMENT_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                -e GIT_COMMIT="${{ github.sha }}" \
                --health-cmd="curl -f http://localhost:$CONTAINER_PORT/health || exit 1" \
                --health-interval=30s \
                --health-timeout=10s \
                --health-retries=3 \
                --health-start-period=40s \
                --log-driver json-file \
                --log-opt max-size=10m \
                --log-opt max-file=3 \
                $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
            
            # Wait for container to be healthy
            log "‚è≥ Waiting for container to be healthy..."
            for i in {1..60}; do
                HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' $CONTAINER_NAME 2>/dev/null || echo "starting")
                case $HEALTH_STATUS in
                    "healthy")
                        log "‚úÖ Container is healthy!"
                        break
                        ;;
                    "unhealthy")
                        error "‚ùå Container is unhealthy"
                        docker logs $CONTAINER_NAME --tail 50
                        exit 1
                        ;;
                    "starting")
                        echo -n "."
                        ;;
                    *)
                        echo -n "?"
                        ;;
                esac
                sleep 5
            done
            echo
            
            # Verify deployment
            log "üîç Verifying deployment..."
            sleep 10  # Give the application time to fully start
            
            if curl -f -s -m 10 http://localhost:$HOST_PORT/health > /dev/null; then
                log "‚úÖ Health check passed!"
            else
                error "‚ùå Health check failed"
                docker logs $CONTAINER_NAME --tail 50
                exit 1
            fi
            
            # Show container status
            log "üìä Container status:"
            docker ps --filter name=$CONTAINER_NAME --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Clean up old images and backups
            log "üßπ Cleaning up old resources..."
            docker image prune -f
            
            # Keep only last 3 backup containers
            docker images --filter "reference=${CONTAINER_NAME}-backup-*" --format "{{.Repository}}:{{.Tag}}" | \
                tail -n +4 | xargs -r docker rmi || true
            
            log "üéâ Deployment completed successfully!"
            log "üåê Application URL: http://$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4):$HOST_PORT"

  cleanup:
    name: Cleanup old ECR images
    needs: deploy-to-ec2
    runs-on: ubuntu-latest
    if: always() && (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Clean up old ECR images
        run: |
          # Keep last 10 images
          IMAGES_TO_DELETE=$(aws ecr list-images \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --filter tagStatus=TAGGED \
            --query 'imageIds[?imageTag!=`latest`]' \
            --output json | \
            jq -r 'sort_by(.imagePushedAt) | reverse | .[10:] | .[] | .imageDigest')
          
          if [ ! -z "$IMAGES_TO_DELETE" ]; then
            echo "Deleting old images..."
            echo "$IMAGES_TO_DELETE" | while read digest; do
              aws ecr batch-delete-image \
                --repository-name ${{ env.ECR_REPOSITORY }} \
                --image-ids imageDigest=$digest || true
            done
          else
            echo "No old images to delete"
          fi
